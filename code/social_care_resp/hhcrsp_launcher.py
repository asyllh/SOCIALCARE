import argparse, os
import hhcrsp_solver as solver
import numpy as np
import instance_handler as hhc
from time import sleep

# import sys
# print(sys.argv)

# loading example arguments
instance_name = ''
ap = argparse.ArgumentParser(description='Arguments for HHCRSP solver')

default_time = 180
default_verbose = 3

# Optional alrguments
ap.add_argument("-plots", "--create_python_plots", type=int, dest='create_python_plots', help="Set create_python_plots", default=0)
ap.add_argument("-html", "--create_html_website", type=int, dest='create_html_website', help="Set create_html_website", default=0)
ap.add_argument("-v", "--verbose_level", type=int, dest='verbose_level', help="Set verbose_level", default=default_verbose)
ap.add_argument("-pw", "--parallel_workers", type=int, dest='parallel_workers', help="Set parallel_workers", default=1)
ap.add_argument("-P", "--run_in_parallel", type=int, dest='run_in_parallel', help="Set run_in_parallel", default=0)
ap.add_argument("-t", "--max_time_seconds", type=int, dest='max_time_seconds', help="Set max_time_seconds", default=default_time)
ap.add_argument("-options_vector", "--options_vector", dest='options_vector', help="Set options_vector", default='')
ap.add_argument("-cn", "--candidatenumber", type=int, dest='file_idx', help="Set file_idx", default=0)
ap.add_argument("-f", "--results_file_name", type=str, dest='results_file_name', help="Set results_file_name (name only, path is given in --workdir)", default='launcher_results.txt')
ap.add_argument("-workdir", "--workdir", type=str, dest='workdir', help="Set workdir. Default is working directory", default=os.getcwd())



# print('reached here?')
# Required arguments
ap.add_argument("-i", "--instance", type=str, required=True, dest='instance_file', help="Instance file (python file with instance, quality measure and skills type)")
ap.add_argument("-iid", "--instance_id", type=str, required=True, dest='instance_id', help="Instance id (generated by irace)")
ap.add_argument("-seed", "--random_seed", type=int, required=True, dest='random_seed', help="Set random_seed")
ap.add_argument("-gap", "--gap_no_prececence", required=True, type=int, dest='gap', help="Use gaps (not precedence) in dependent jobs")


# GRASP-related options
ap.add_argument("-no_change_grasp", "--no_change_grasp", type=float, required=False, dest='no_change_grasp', help="Nurse order change (GRASP)", default=-123)
# ap.add_argument("-performPathRelinking", "--performPathRelinking", type=float, required=False, dest='performPathRelinking', help="performPathRelinking")
ap.add_argument("-rcl_strategy", "--rcl_strategy", type=float, dest='rcl_strategy', help="rcl_strategy", default=-123)
ap.add_argument("-pr_strategy", "--pr_strategy", type=float, required=False, dest='pr_strategy', help="Type of path relinking (see paper section PR->Type)", default=-123)
ap.add_argument("-pr_direction", "--pr_direction", type=float, required=False, dest='pr_direction', help="Direction of PR (0 forward, 1 backward, 2 forward & backward, 3 random)", default=-123)

# ap.add_argument("-performPathRelinking_every_sol", "--performPathRelinking_every_sol", type=float, required=True, dest='performPathRelinking_every_sol', help="performPathRelinking_every_sol")
ap.add_argument("-sols_in_pool", "--sols_in_pool", type=float, required=False, dest='sols_in_pool', help="sols_in_pool", default=-123)
ap.add_argument("-no_change_ls", "--no_change_ls", type=float, required=False, dest='no_change_ls', help="no_change_ls", default=-123)
ap.add_argument("-do_twopt", "--do_twopt", type=float, required=False, dest='do_twopt', help="do_twopt", default=-123)
ap.add_argument("-grasp_dl", "--grasp_dl", type=float, required=False, dest='grasp_dl', help="grasp_dl", default=-123)
ap.add_argument("-grasp_dr", "--grasp_dr", type=float, required=False, dest='grasp_dr', help="grasp_dr", default=-123)

args = ap.parse_args()

# Translate to vector:
options_vector = hhc.default_options_vector()

if abs(args.no_change_grasp + 123 <= 0.001):
	print('Warning: Argument args.no_change_grasp not passed, set to default!')
	options_vector[6] = 0
else:
	options_vector[6] = args.no_change_grasp # Nurse order change active (In GRASP, between calls)

# if abs(args.performPathRelinking + 123 <= 0.001):
# 	print('Warning: Argument args.performPathRelinking not passed, set to default!')
# 	options_vector[7] = 0
# else:
# 	options_vector[7] = args.performPathRelinking # performPathRelinking

if abs(args.sols_in_pool + 123 <= 0.001):
	print('Warning: Argument args.sols_in_pool not passed, set to default!')
	options_vector[8] = 10
else:
	options_vector[8] = args.sols_in_pool # Solutions in pool

if abs(args.no_change_ls + 123 <= 0.001):
	print('Warning: Argument args.no_change_ls not passed, set to default!')
	options_vector[3] = 0
else:
	options_vector[3] = args.no_change_ls # Nurse order change active (neighbourhood in local search)

if abs(args.do_twopt + 123 <= 0.001):
	print('Warning: Argument args.do_twopt not passed, set to default!')
	options_vector[1] = 0
else:
	options_vector[1] = args.do_twopt # Two-opt active

if abs(args.grasp_dl + 123 <= 0.001):
	print('Warning: Argument args.grasp_dl not passed, set to default!')
	options_vector[4] = 0.1
else:
	options_vector[4] = args.grasp_dl # -   GRASP: Delta low

if abs(args.grasp_dr + 123 <= 0.001):
	print('Warning: Argument args.grasp_dr not passed, set to default!')
	options_vector[5] = 0.1
else:
	options_vector[5] = args.grasp_dr # -   GRASP: Delta range

if abs(args.pr_strategy + 123 <= 0.001):
	print('Warning: Argument args.pr_strategy not passed, set to default!')
	options_vector[9] = 0.5
else:
	options_vector[9] = args.pr_strategy # Type of path relinking

if abs(args.rcl_strategy + 123 <= 0.001):
	print('Warning: Argument args.rcl_strategy not passed, set to default!')
	options_vector[10] = 1
else:
	options_vector[10] = args.rcl_strategy # Strategy for generating RCL in GRASP

if abs(args.pr_direction + 123 <= 0.001):
	print('Warning: Argument args.pr_direction not passed, set to default!')
	options_vector[11] = 1
else:
	options_vector[11] = args.pr_direction # Direction of PR (0 forward, 1 backward, 2 forward & backward, 3 random)

options_vector[12] = args.gap # Use precedence (0) or gap (1) constraints for interdependent jobs


# args.options_vector = options_vector

# Decide on quality measure and skill type based on extension
# .aith or .mk
extension = os.path.splitext(args.instance_file)[1]
args.ds_skill_type = 'strictly-shared'
args.instance_type = 'ait_h'
args.quality_measure = 'mankowska'
args.load_from_disk = False


if extension == '.p':
    args.ds_skill_type = 'strictly-shared'
    args.instance_type = 'pfile'

if extension == '.mkmat':
    args.ds_skill_type = 'strictly-shared'
    args.instance_type = 'mankowska-mat'
if extension == '.mkvns':
    args.ds_skill_type = 'strictly-shared'
    args.instance_type = 'mankowska-vns'

print('Calling SOLVER')
quality = solver.solver(args, args.instance_file, options_vector)



# Sleep a bit to let the C function finish writting:
for iii in range(5):
	sleep(1)

print('Back in LAUNCHER')
print('\n\n\n' + str(quality))
