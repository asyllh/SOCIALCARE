import argparse, os
import dst_solver as solver
import numpy as np
import instance_handler_idict as hhc
from time import sleep

# import sys
# print(sys.argv)

# loading example arguments
instance_name = ''
ap = argparse.ArgumentParser(description='Arguments for DST solver')

default_time = 180
default_verbose = 3

# Required arguments
ap.add_argument("-i", "--instance", type=str, required=True, dest='instance_file', help="Instance file (python file with instance, quality measure and skills type)")
# ap.add_argument("-iid", "--instance_id", type=str, required=True, dest='instance_id', help="Instance id (generated by irace)")
ap.add_argument("-seed", "--random_seed", type=int, required=True, dest='random_seed', help="Set random_seed")

# Optional arguments
ap.add_argument("-plots", "--create_python_plots", type=int, dest='create_python_plots', help="Set create_python_plots")
ap.add_argument("-html", "--create_html_website", type=int, dest='create_html_website', help="Set create_html_website")
# ap.add_argument("-v", "--verbose_level", type=int, dest='verbose_level', help="Set verbose_level", default=default_verbose)
# ap.add_argument("-pw", "--parallel_workers", type=int, dest='parallel_workers', help="Set parallel_workers", default=1)
# ap.add_argument("-P", "--run_in_parallel", type=int, dest='run_in_parallel', help="Set run_in_parallel", default=0)
ap.add_argument("-t", "--max_time_seconds", type=int, dest='max_time_seconds', help="Set max_time_seconds", default=default_time)
# ap.add_argument("-ov", "--options_vector", dest='options_vector', help="Set options_vector", default='')
# ap.add_argument("-cn", "--candidatenumber", type=int, dest='file_idx', help="Set file_idx", default=0)
ap.add_argument("-f", "--results_filename", type=str, dest='results_filename', help="Set results_filename (name only, path is given in --workdir)")
ap.add_argument("-workdir", "--workdir", type=str, dest='workdir', help="Set workdir. Default is working directory", default=os.getcwd())

# GRASP-related options
ap.add_argument("-do_twopt", "--do_twopt", type=float, required=False, help="do_twopt") # ov[1]
ap.add_argument("-no_change_ls", "--no_change_ls", type=float, required=False, dest='no_change_ls', help="no_change_ls") #ov[3]
ap.add_argument("-grasp_dl", "--grasp_dl", type=float, required=False, dest='grasp_dl', help="grasp_dl") #ov[4]
ap.add_argument("-grasp_dr", "--grasp_dr", type=float, required=False, dest='grasp_dr', help="grasp_dr") # ov[5]
ap.add_argument("-no_change_grasp", "--no_change_grasp", type=float, required=False, dest='no_change_grasp', help="Nurse order change (GRASP)") # ov[6]
ap.add_argument("-sols_in_pool", "--sols_in_pool", type=float, required=False, dest='sols_in_pool', help="sols_in_pool") # ov[8]
ap.add_argument("-pr_strategy", "--pr_strategy", type=float, required=False, dest='pr_strategy', help="Type of path relinking (see paper section PR->Type)") # ov[9]
ap.add_argument("-rcl_strategy", "--rcl_strategy", type=float, dest='rcl_strategy', help="rcl_strategy") # ov[10]
ap.add_argument("-pr_direction", "--pr_direction", type=float, required=False, dest='pr_direction', help="Direction of PR (0 forward, 1 backward, 2 forward & backward, 3 random)") # ov[11]
ap.add_argument("-gap", "--gap_no_prececence", required=False, type=int, dest='gap', help="Use gaps (not precedence) in dependent jobs") # ov[12]

args = ap.parse_args()

# Translate to vector:
options_vector = hhc.default_options_vector()

for i in range(13):
    print('ov i: ', options_vector[i])
# exit(-1)
print('\n')

if args.do_twopt:
    options_vector[1] = args.do_twopt 
else:
    print('Warning: Argument args.do_twopt not passed, leave as default.')

if args.no_change_ls:
    options_vector[3] = args.no_change_ls 
else:
    print('Warning: Argument args.no_change_ls not passed, leave as default.')

if args.grasp_dl:
    options_vector[4] = args.grasp_dl 
else:
    print('Warning: Argument args.grasp_dl not passed, leave as default.')


if args.grasp_dr:
    options_vector[5] = args.grasp_dr 
else:
    print('Warning: Argument args.grasp_dr not passed, leave as default.')


if args.no_change_grasp:
    options_vector[6] = args.no_change_grasp 
else:
    print('Warning: Argument args.no_change_grasp not passed, leave as default.')


if args.sols_in_pool:
    options_vector[8] = args.sols_in_pool 
else:
    print('Warning: Argument args.sols_in_pool not passed, leave as default.')


if args.pr_strategy:
    options_vector[9] = args.pr_strategy 
else:
    print('Warning: Argument args.pr_strategy not passed, leave as default.')


if args.rcl_strategy:
    options_vector[10] = args.rcl_strategy 
else:
    print('Warning: Argument args.rcl_strategy not passed, leave as default.')


if args.pr_direction:
    options_vector[1] = args.pr_direction 
else:
    print('Warning: Argument args.pr_direction not passed, leave as default.')


if args.gap:
    options_vector[1] = args.gap
else:
    print('Warning: Argument args.gap not passed, leave as default.')


for i in range(13):
    print('ov i: ', options_vector[i])
exit(-1)




# args.options_vector = options_vector

# Decide on quality measure and skill type based on extension
# .aith or .mk
# extension = os.path.splitext(args.instance_file)[1]
args.ds_skill_type = 'strictly-shared'
# args.instance_type = 'ait_h'
# args.quality_measure = 'mankowska'
# args.load_from_disk = False

print('Done.')
exit(-1)
print('Calling SOLVER')
# quality = solver.solver(args, args.instance_file, options_vector)



# Sleep a bit to let the C function finish writting:
for iii in range(5):
	sleep(1)

print('Back in LAUNCHER')
print('\n\n\n' + str(quality))
